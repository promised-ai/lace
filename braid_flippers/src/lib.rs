use std::f64::NEG_INFINITY;

use braid_utils::Matrix;
use rand::distributions::Uniform;
use rand::Rng;
use rayon::prelude::*;

pub fn massflip_mat<R: Rng>(logps: &Matrix<f64>, rng: &mut R) -> Vec<usize> {
    if logps.ncols() == 1 {
        panic!("K should never be 1")
    }

    let nrows = logps.nrows();
    let ncols = logps.ncols();

    (0..nrows)
        .map(|i| {
            let logp0 = logps[(i, 0)];
            let mut ps: Vec<f64> = Vec::with_capacity(ncols);
            ps.push(logp0);

            let maxval = (1..ncols).fold(logp0, |max, j| {
                let logp = logps[(i, j)];
                ps.push(logp);
                if logp > max {
                    logp
                } else {
                    max
                }
            });

            ps[0] = (logp0 - maxval).exp();
            (1..ncols).for_each(|j| {
                let p = (ps[j] - maxval).exp() + ps[j - 1];
                ps[j] = p;
            });

            let r: f64 = rng.gen::<f64>() * ps[ncols - 1];

            ps.iter().fold(0_u16, |acc, p| acc + (*p < r) as u16) as usize
        })
        .collect()
}

pub fn massflip_mat_par<R: Rng>(
    logps: &Matrix<f64>,
    rng: &mut R,
) -> Vec<usize> {
    if logps.ncols() == 1 {
        panic!("K should never be 1")
    }

    let k = logps.ncols();

    let rs: Vec<f64> = (0..logps.nrows()).map(|_| rng.gen::<f64>()).collect();

    rs.par_iter()
        .enumerate()
        .map(|(i, &u)| {
            let maxval = (0..k).fold(logps[(i, 0)], |max, j| {
                let val = logps[(i, j)];
                if val > max {
                    val
                } else {
                    max
                }
            });

            let mut ps: Vec<f64> = Vec::with_capacity(k);
            (0..k).fold(0.0, |prev, j| {
                let p = (logps[(i, j)] - maxval).exp() + prev;
                ps.push(p);
                p
            });

            let r = u * ps[k - 1];

            let ct =
                ps.iter().fold(0_u16, |acc, &p| acc + (p < r) as u16) as usize;

            ct
        })
        .collect()
}

/// Draw n categorical indices in {0,..,k-1} from an n-by-k vector of vectors
/// of un-normalized log probabilities, ignoring -Inf entries.
///
/// NOTE: For use only with the slice sampler. Expects the truncated
/// probabilites generated by the slice sampling proceedure (see
/// View::reassign_rows_slice).
pub fn massflip_slice<R: Rng>(
    mut logps: Vec<Vec<f64>>,
    rng: &mut R,
) -> Vec<usize> {
    let k = logps[0].len();
    let mut ixs: Vec<usize> = Vec::with_capacity(logps.len());
    let u = Uniform::new(0.0, 1.0);

    for lps in &mut logps {
        let maxval =
            lps.iter().fold(
                NEG_INFINITY,
                |max, &val| {
                    if val > max {
                        val
                    } else {
                        max
                    }
                },
            );

        // XXX: using is lps[i] != NEG_INFINITY saves 2 EQ comparisons, two ORs,
        // and one NOT compared to lps[i].is_finite(). We only care whether the
        // entry is log(0) == NEG_INFINITY. If something is NAN of Inf, then we
        // have other problems.
        if lps[0] != NEG_INFINITY {
            lps[0] -= maxval;
            lps[0] = lps[0].exp();
        } else {
            lps[0] = 0.0;
        }

        for i in 1..k {
            if lps[i] != NEG_INFINITY {
                lps[i] -= maxval;
                lps[i] = lps[i].exp();
                lps[i] += lps[i - 1];
            } else {
                lps[i] = lps[i - 1];
            }
        }

        let scale: f64 = *lps.last().unwrap();
        let r: f64 = rng.sample(u) * scale;

        let mut ct: usize = 0;
        for p in lps {
            ct += (*p < r) as usize;
        }
        ixs.push(ct);
    }
    ixs
}

pub fn massflip_slice_mat<R: Rng>(
    logps: &Matrix<f64>,
    rng: &mut R,
) -> Vec<usize> {
    let nrows = logps.nrows();
    let ncols = logps.ncols();

    (0..nrows)
        .map(|i| {
            let maxval = (1..ncols).fold(logps[(i, 0)], |max, j| {
                let val = logps[(i, j)];
                if val > max {
                    val
                } else {
                    max
                }
            });

            // XXX: using is lps[i] != NEG_INFINITY saves 2 EQ comparisons, two ORs,
            // and one NOT compared to lps[i].is_finite(). We only care whether the
            // entry is log(0) == NEG_INFINITY. If something is NAN of Inf, then we
            // have other problems.
            let mut ps: Vec<f64> = Vec::with_capacity(ncols);
            (0..ncols).fold(0.0, |prev, j| {
                let logp = logps[(i, j)];
                let value = if logp != NEG_INFINITY {
                    (logp - maxval).exp() + prev
                } else {
                    prev
                };
                ps.push(value);
                value
            });

            let scale: f64 = ps[ncols - 1];
            let r: f64 = rng.gen::<f64>() * scale;

            ps.iter()
                .fold(0_usize, |acc, p| if *p < r { acc + 1 } else { acc })
        })
        .collect()
}

pub fn massflip_slice_mat_par<R: Rng>(
    logps: &Matrix<f64>,
    rng: &mut R,
) -> Vec<usize> {
    let nrows = logps.nrows();
    let ncols = logps.ncols();

    let us: Vec<f64> = (0..nrows).map(|_| rng.gen::<f64>()).collect();

    us.par_iter()
        .enumerate()
        .map(|(i, &u)| {
            let maxval = (1..ncols).fold(logps[(i, 0)], |max, j| {
                let val = logps[(i, j)];
                if val > max {
                    val
                } else {
                    max
                }
            });

            // XXX: using is lps[i] != NEG_INFINITY saves 2 EQ comparisons, two ORs,
            // and one NOT compared to lps[i].is_finite(). We only care whether the
            // entry is log(0) == NEG_INFINITY. If something is NAN of Inf, then we
            // have other problems.
            let mut ps: Vec<f64> = Vec::with_capacity(ncols);
            (0..ncols).fold(0.0, |prev, j| {
                let logp = logps[(i, j)];
                let value = if logp != NEG_INFINITY {
                    (logp - maxval).exp() + prev
                } else {
                    prev
                };
                ps.push(value);
                value
            });

            let scale: f64 = ps[ncols - 1];
            let r: f64 = u * scale;

            ps.iter()
                .fold(0_usize, |acc, p| if *p < r { acc + 1 } else { acc })
        })
        .collect()
}

/// Draw n categorical indices in {0,..,k-1} from an n-by-k vector of vectors
/// of un-normalized log probabilities
pub fn massflip_ser<R: Rng>(
    mut logps: Vec<Vec<f64>>,
    rng: &mut R,
) -> Vec<usize> {
    let k = logps[0].len();
    let mut ixs: Vec<usize> = Vec::with_capacity(logps.len());
    let u = Uniform::new(0.0, 1.0);

    for lps in &mut logps {
        // ixs.push(log_pflip(&lps, &mut rng)); // debug
        let maxval =
            lps.iter().fold(
                NEG_INFINITY,
                |max, &val| {
                    if val > max {
                        val
                    } else {
                        max
                    }
                },
            );
        lps[0] -= maxval;
        lps[0] = lps[0].exp();
        for i in 1..k {
            lps[i] -= maxval;
            lps[i] = lps[i].exp();
            lps[i] += lps[i - 1];
        }

        let scale: f64 = *lps.last().unwrap();
        let r: f64 = rng.sample(u) * scale;

        let mut ct: usize = 0;
        for p in lps {
            ct += (*p < r) as usize;
        }
        ixs.push(ct);
    }
    ixs
}

pub fn massflip_ser_fe<R: Rng>(
    mut logps: Vec<Vec<f64>>,
    rng: &mut R,
) -> Vec<usize> {
    let k = logps[0].len();

    if k == 1 {
        return vec![0];
    }
    let mut ixs: Vec<usize> = Vec::with_capacity(logps.len());

    for lps in &mut logps {
        let maxval =
            lps.iter().fold(
                NEG_INFINITY,
                |max, &val| {
                    if val > max {
                        val
                    } else {
                        max
                    }
                },
            );

        // lps hould always be at least length 2
        lps[0] = (lps[0] - maxval).exp();
        lps[1] = ((lps[1] - maxval).exp()) + lps[0];

        let start = lps[1];
        lps.iter_mut().skip(2).fold(start, |prev, lp| {
            *lp = (*lp - maxval).exp() + prev;
            *lp
        });

        let r: f64 = rng.gen::<f64>() * lps[k - 1];

        let ct =
            lps.iter().fold(0_u16, |acc, p| acc + (*p < r) as u16) as usize;

        ixs.push(ct);
    }
    ixs
}

/// Draw n categorical indices in {0,..,k-1} from an n-by-k vector of vectors
/// of un-normalized log probabilities in parallel using rayon
pub fn massflip_par<R: Rng>(
    mut logps: Vec<Vec<f64>>,
    rng: &mut R,
) -> Vec<usize> {
    let n = logps.len();
    let k = logps[0].len();
    let u = Uniform::new(0.0, 1.0);
    let us: Vec<f64> = (0..n).map(|_| rng.sample(u)).collect();

    let mut out: Vec<usize> = Vec::with_capacity(n);
    logps
        .par_iter_mut()
        .zip_eq(us.par_iter())
        .map(|(lps, u)| {
            let maxval = lps.iter().fold(NEG_INFINITY, |max, &val| {
                if val > max {
                    val
                } else {
                    max
                }
            });
            lps[0] -= maxval;
            lps[0] = lps[0].exp();
            for i in 1..k {
                lps[i] -= maxval;
                lps[i] = lps[i].exp();
                lps[i] += lps[i - 1]
            }

            let r = u * *lps.last().unwrap();

            // Is a for loop faster?
            lps.iter().fold(0, |acc, &p| acc + ((p < r) as usize))
        })
        .collect_into_vec(&mut out);
    out
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::SeedableRng;
    use rand_xoshiro::Xoshiro256Plus;

    fn gen_weights(nrows: usize, ncols: usize) -> Vec<Vec<f64>> {
        let mut rng = Xoshiro256Plus::seed_from_u64(1337);
        let logps: Vec<Vec<f64>> = (0..nrows)
            .map(|_| {
                let mut ps: Vec<f64> =
                    (0..ncols).map(|_| rng.gen::<f64>()).collect();
                let sum: f64 = ps.iter().sum::<f64>();
                ps.drain(..).map(|p| (p / sum).ln()).collect::<Vec<f64>>()
            })
            .collect();

        logps
    }

    #[test]
    fn massflip_ser_should_return_valid_indices() {
        let mut rng = Xoshiro256Plus::seed_from_u64(1337);
        let log_weights: Vec<Vec<f64>> = vec![vec![0.0; 5]; 50];
        let ixs = massflip_ser(log_weights, &mut rng);
        assert!(ixs.iter().all(|&ix| ix < 5));
    }

    #[test]
    fn massflip_par_should_return_valid_indices() {
        let mut rng = Xoshiro256Plus::seed_from_u64(1337);
        let log_weights: Vec<Vec<f64>> = vec![vec![0.0; 5]; 50];
        let ixs = massflip_par(log_weights, &mut rng);
        assert!(ixs.iter().all(|&ix| ix < 5));
    }

    #[test]
    fn serial_plan_and_fe_should_be_same_with_same_seed() {
        let ixs_ser = {
            let mut rng = Xoshiro256Plus::seed_from_u64(1337);
            let log_weights: Vec<Vec<f64>> = vec![vec![0.0; 5]; 100];
            massflip_ser(log_weights, &mut rng)
        };
        let ixs_fe = {
            let mut rng = Xoshiro256Plus::seed_from_u64(1337);
            let log_weights: Vec<Vec<f64>> = vec![vec![0.0; 5]; 100];
            massflip_ser_fe(log_weights, &mut rng)
        };

        assert!(ixs_ser
            .iter()
            .zip(ixs_fe.iter())
            .all(|(ix_1, ix_2)| ix_1 == ix_2));
    }

    #[test]
    fn serial_matrix_and_normal_are_the_same_for_same_seed() {
        let logps = gen_weights(100, 5);
        let ixs_ser = {
            let mut rng = Xoshiro256Plus::seed_from_u64(1337);
            massflip_ser_fe(logps.clone(), &mut rng)
        };

        let ixs_mat = {
            // will be transposed inside
            let logps_m = Matrix::from_vecs(&logps);
            let mut rng = Xoshiro256Plus::seed_from_u64(1337);
            massflip_mat(&logps_m, &mut rng)
        };

        assert_eq!(ixs_mat.len(), ixs_ser.len());

        for (a, b) in ixs_ser.iter().zip(ixs_mat.iter()) {
            assert_eq!(a, b);
        }
    }

    #[test]
    fn serial_and_par_matrix_are_the_same_for_same_seed() {
        let logps = gen_weights(100, 5);
        let ixs_ser = {
            // will be transposed inside
            let logps_m = Matrix::from_vecs(&logps);
            let mut rng = Xoshiro256Plus::seed_from_u64(1337);
            massflip_mat_par(&logps_m, &mut rng)
        };

        let ixs_par = {
            // will be transposed inside
            let logps_m = Matrix::from_vecs(&logps);
            let mut rng = Xoshiro256Plus::seed_from_u64(1337);
            massflip_mat(&logps_m, &mut rng)
        };

        assert_eq!(ixs_par.len(), ixs_ser.len());

        for (a, b) in ixs_ser.iter().zip(ixs_par.iter()) {
            assert_eq!(a, b);
        }
    }

    #[test]
    fn massflip_slice_mat_and_normal_are_the_same_for_same_seed() {
        let logps = {
            let mut rng = Xoshiro256Plus::seed_from_u64(1337);
            let mut logps = gen_weights(100, 5);
            for i in 0..100 {
                let u = (rng.gen::<f64>() * logps[i][0].exp()).ln();

                for j in 0..5 {
                    if logps[i][j] < u {
                        logps[i][j] = NEG_INFINITY;
                    }
                }
            }
            logps
        };

        let ixs_mat = {
            let logps_m = Matrix::from_vecs(&logps);
            let mut rng = Xoshiro256Plus::seed_from_u64(1337);
            massflip_slice_mat(&logps_m, &mut rng)
        };

        let ixs_vec = {
            let mut rng = Xoshiro256Plus::seed_from_u64(1337);
            massflip_slice(logps, &mut rng)
        };

        assert_eq!(ixs_mat.len(), ixs_vec.len());

        for (a, b) in ixs_mat.iter().zip(ixs_vec.iter()) {
            assert_eq!(a, b);
        }
    }
}
