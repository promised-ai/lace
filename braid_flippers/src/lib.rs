use std::f64::NEG_INFINITY;

use rand::distributions::Uniform;
use rand::Rng;
use rayon::prelude::*;

/// Draw n categorical indices in {0,..,k-1} from an n-by-k vector of vectors
/// of un-normalized log probabilities, ignoring -Inf entries.
///
/// NOTE: For use only with the slice sampler. Expects the truncated
/// probabilites generated by the slice sampling proceedure (see
/// View::reassign_rows_slice).
pub fn massflip_slice<R: Rng>(
    mut logps: Vec<Vec<f64>>,
    rng: &mut R,
) -> Vec<usize> {
    let k = logps[0].len();
    let mut ixs: Vec<usize> = Vec::with_capacity(logps.len());
    let u = Uniform::new(0.0, 1.0);

    for lps in &mut logps {
        // ixs.push(log_pflip(&lps, &mut rng)); // debug
        let maxval =
            lps.iter().fold(
                NEG_INFINITY,
                |max, &val| {
                    if val > max {
                        val
                    } else {
                        max
                    }
                },
            );

        // XXX: using is lps[i] != NEG_INFINITY saves 2 EQ comparisons, two ORs,
        // and one NOT compared to lps[i].is_finite(). We only care whether the
        // entry is log(0) == NEG_INFINITY. If something is NAN of Inf, then we
        // have other problems.
        if lps[0] != NEG_INFINITY {
            lps[0] -= maxval;
            lps[0] = lps[0].exp();
        } else {
            lps[0] = 0.0;
        }

        for i in 1..k {
            if lps[i] != NEG_INFINITY {
                lps[i] -= maxval;
                lps[i] = lps[i].exp();
                lps[i] += lps[i - 1];
            } else {
                lps[i] = lps[i - 1];
            }
        }

        let scale: f64 = *lps.last().unwrap();
        let r: f64 = rng.sample(u) * scale;

        let mut ct: usize = 0;
        for p in lps {
            ct += (*p < r) as usize;
        }
        ixs.push(ct);
    }
    ixs
}

/// Draw n categorical indices in {0,..,k-1} from an n-by-k vector of vectors
/// of un-normalized log probabilities
pub fn massflip_ser<R: Rng>(
    mut logps: Vec<Vec<f64>>,
    rng: &mut R,
) -> Vec<usize> {
    let k = logps[0].len();
    let mut ixs: Vec<usize> = Vec::with_capacity(logps.len());
    let u = Uniform::new(0.0, 1.0);

    for lps in &mut logps {
        // ixs.push(log_pflip(&lps, &mut rng)); // debug
        let maxval =
            lps.iter().fold(
                NEG_INFINITY,
                |max, &val| {
                    if val > max {
                        val
                    } else {
                        max
                    }
                },
            );
        lps[0] -= maxval;
        lps[0] = lps[0].exp();
        for i in 1..k {
            lps[i] -= maxval;
            lps[i] = lps[i].exp();
            lps[i] += lps[i - 1];
        }

        let scale: f64 = *lps.last().unwrap();
        let r: f64 = rng.sample(u) * scale;

        let mut ct: usize = 0;
        for p in lps {
            ct += (*p < r) as usize;
        }
        ixs.push(ct);
    }
    ixs
}

pub fn massflip_ser_fe<R: Rng>(
    mut logps: Vec<Vec<f64>>,
    rng: &mut R,
) -> Vec<usize> {
    let k = logps[0].len();

    if k == 1 {
        return vec![0];
    }
    let mut ixs: Vec<usize> = Vec::with_capacity(logps.len());

    for lps in &mut logps {
        let maxval =
            lps.iter().fold(
                NEG_INFINITY,
                |max, &val| {
                    if val > max {
                        val
                    } else {
                        max
                    }
                },
            );

        // lps hould always be at least length 2
        lps[0] = (lps[0] - maxval).exp();
        lps[1] = ((lps[1] - maxval).exp()) + lps[0];

        let start = lps[1];
        lps.iter_mut().skip(2).fold(start, |prev, lp| {
            *lp = (*lp - maxval).exp() + prev;
            *lp
        });

        let r: f64 = rng.gen::<f64>() * lps[k - 1];

        let ct =
            lps.iter().fold(0_u16, |acc, p| acc + (*p < r) as u16) as usize;

        ixs.push(ct);
    }
    ixs
}

/// Draw n categorical indices in {0,..,k-1} from an n-by-k vector of vectors
/// of un-normalized log probabilities in parallel using rayon
pub fn massflip_par<R: Rng>(
    mut logps: Vec<Vec<f64>>,
    rng: &mut R,
) -> Vec<usize> {
    let n = logps.len();
    let k = logps[0].len();
    let u = Uniform::new(0.0, 1.0);
    let us: Vec<f64> = (0..n).map(|_| rng.sample(u)).collect();

    let mut out: Vec<usize> = Vec::with_capacity(n);
    logps
        .par_iter_mut()
        .zip_eq(us.par_iter())
        .map(|(lps, u)| {
            let maxval = lps.iter().fold(NEG_INFINITY, |max, &val| {
                if val > max {
                    val
                } else {
                    max
                }
            });
            lps[0] -= maxval;
            lps[0] = lps[0].exp();
            for i in 1..k {
                lps[i] -= maxval;
                lps[i] = lps[i].exp();
                lps[i] += lps[i - 1]
            }

            let r = u * *lps.last().unwrap();

            // Is a for loop faster?
            lps.iter().fold(0, |acc, &p| acc + ((p < r) as usize))
        })
        .collect_into_vec(&mut out);
    out
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::SeedableRng;
    use rand_xoshiro::Xoshiro256Plus;

    #[test]
    fn massflip_ser_should_return_valid_indices() {
        let mut rng = Xoshiro256Plus::seed_from_u64(1337);
        let log_weights: Vec<Vec<f64>> = vec![vec![0.0; 5]; 50];
        let ixs = massflip_ser(log_weights, &mut rng);
        assert!(ixs.iter().all(|&ix| ix < 5));
    }

    #[test]
    fn massflip_par_should_return_valid_indices() {
        let mut rng = Xoshiro256Plus::seed_from_u64(1337);
        let log_weights: Vec<Vec<f64>> = vec![vec![0.0; 5]; 50];
        let ixs = massflip_par(log_weights, &mut rng);
        assert!(ixs.iter().all(|&ix| ix < 5));
    }

    #[test]
    fn serial_plan_and_fe_should_be_same_with_same_seed() {
        let ixs_ser = {
            let mut rng = Xoshiro256Plus::seed_from_u64(1337);
            let log_weights: Vec<Vec<f64>> = vec![vec![0.0; 5]; 100];
            massflip_ser(log_weights, &mut rng)
        };
        let ixs_fe = {
            let mut rng = Xoshiro256Plus::seed_from_u64(1337);
            let log_weights: Vec<Vec<f64>> = vec![vec![0.0; 5]; 100];
            massflip_ser_fe(log_weights, &mut rng)
        };

        assert!(ixs_ser
            .iter()
            .zip(ixs_fe.iter())
            .all(|(ix_1, ix_2)| ix_1 == ix_2));
    }
}
