use warp::{
    http::HeaderValue,
    hyper::{header::CONTENT_TYPE, StatusCode},
};

mod helpers;

#[test_log::test(tokio::test)]
async fn download_after_update() {
    let filter = helpers::fixture(false);

    let query = r#"{
        "n_iters": 10,
        "timeout": 20,
        "transitions": [
            {"row_assignment": "gibbs"},
            {"column_assignment": "gibbs"},
            "component_params",
            "feature_priors",
            "state_alpha",
            "view_alphas"
        ]
    }"#;

    let (parts, _body) = {
        warp::test::request()
            .path("/api/v1/update")
            .method("POST")
            .body(query)
            .header(CONTENT_TYPE, "application/json")
            .reply(&filter)
            .await;

        warp::test::request()
            .path("/api/v1/download")
            .method("GET")
            .reply(&filter)
            .await
    }
    .into_parts();

    assert_eq!(parts.status, StatusCode::OK);
    assert_eq!(
        parts.headers.get(CONTENT_TYPE),
        Some(&HeaderValue::from_static("application/gzip"))
    );
}

#[test_log::test(tokio::test)]
async fn download_without_update() {
    // this test checks whether the metadata file is generated on demand if
    // it hasn't been already generated by a mutating function.
    let filter = helpers::fixture(false);

    let (parts, _body) = warp::test::request()
        .path("/api/v1/download")
        .method("GET")
        .reply(&filter)
        .await
        .into_parts();

    assert_eq!(parts.status, StatusCode::OK);
    assert_eq!(
        parts.headers.get(CONTENT_TYPE),
        Some(&HeaderValue::from_static("application/gzip"))
    );
}
